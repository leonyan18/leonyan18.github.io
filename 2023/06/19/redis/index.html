<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="blog"><meta name="msapplication-TileImage" content="/images/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="线程模型Redis 是单线程吗？Redis单线程指的是【接收客户端请求-&amp;gt;解析请求-&amp;gt;对数据进行读写操作-&amp;gt;发送数据给客户端】这个过程由主线程完成的 在2.6版本会启动处理关闭文件和AOF刷盘任务 4.0版本会增加lazyFree线程释放内存，例如unlink key 、flushdb async、 flushall async 会把删除命令提交给后台线程操作，这样不会阻塞主线程"><meta property="og:type" content="blog"><meta property="og:title" content="blog"><meta property="og:url" content="http://dawnchannel.tech/2023/06/19/redis/"><meta property="og:site_name" content="blog"><meta property="og:description" content="线程模型Redis 是单线程吗？Redis单线程指的是【接收客户端请求-&amp;gt;解析请求-&amp;gt;对数据进行读写操作-&amp;gt;发送数据给客户端】这个过程由主线程完成的 在2.6版本会启动处理关闭文件和AOF刷盘任务 4.0版本会增加lazyFree线程释放内存，例如unlink key 、flushdb async、 flushall async 会把删除命令提交给后台线程操作，这样不会阻塞主线程"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonyan18/image/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonyan18/image/516738c4058cdf9109e40a7812ef4239.png"><meta property="og:image" content="https://cdn.xiaolincoding.com//mysql/other/a3b1f6235cf0587115b21312fe60289c.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonyan18/image/20201228011553.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonyan18/image/20201228011642.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011750.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonyan18/image/6f0ab40396b7fc2c15e6f4487d3a0ad7.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonyan18/image/5a1f2a90b5f3821c19bea3b7a5f27fa1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonyan18/image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309231944807.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/leonyan18/image/%E8%BF%87%E6%9C%9F%E5%88%A4%E6%96%AD%E6%B5%81%E7%A8%8B.jpg"><meta property="article:published_time" content="2023-06-19T01:25:00.000Z"><meta property="article:modified_time" content="2023-08-11T05:42:07.400Z"><meta property="article:author" content="leon Yan"><meta property="article:tag" content="redis"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn.jsdelivr.net/gh/leonyan18/image/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://dawnchannel.tech/2023/06/19/redis/"},"headline":"blog","image":["https://cdn.jsdelivr.net/gh/leonyan18/image/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png","https://cdn.jsdelivr.net/gh/leonyan18/image/516738c4058cdf9109e40a7812ef4239.png","https://cdn.xiaolincoding.com//mysql/other/a3b1f6235cf0587115b21312fe60289c.png","https://cdn.jsdelivr.net/gh/leonyan18/image/20201228011553.png","https://cdn.jsdelivr.net/gh/leonyan18/image/20201228011642.png","https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011750.png","https://cdn.jsdelivr.net/gh/leonyan18/image/6f0ab40396b7fc2c15e6f4487d3a0ad7.png","https://cdn.jsdelivr.net/gh/leonyan18/image/5a1f2a90b5f3821c19bea3b7a5f27fa1.png","https://cdn.jsdelivr.net/gh/leonyan18/image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309231944807.png","https://cdn.jsdelivr.net/gh/leonyan18/image/%E8%BF%87%E6%9C%9F%E5%88%A4%E6%96%AD%E6%B5%81%E7%A8%8B.jpg"],"datePublished":"2023-06-19T01:25:00.000Z","dateModified":"2023-08-11T05:42:07.400Z","author":{"@type":"Person","name":"leon Yan"},"publisher":{"@type":"Organization","name":"blog","logo":{"@type":"ImageObject","url":"http://dawnchannel.tech/images/avatar.png"}},"description":"线程模型Redis 是单线程吗？Redis单线程指的是【接收客户端请求-&gt;解析请求-&gt;对数据进行读写操作-&gt;发送数据给客户端】这个过程由主线程完成的 在2.6版本会启动处理关闭文件和AOF刷盘任务 4.0版本会增加lazyFree线程释放内存，例如unlink key 、flushdb async、 flushall async 会把删除命令提交给后台线程操作，这样不会阻塞主线程"}</script><link rel="canonical" href="http://dawnchannel.tech/2023/06/19/redis/"><link rel="icon" href="/images/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer=""></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/avatar.png" alt="blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">分类</a><a class="navbar-item" href="/categories">归档</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/leonyan18"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2023-06-19T01:25:00.000Z" title="2023/6/19 09:25:00">2023-06-19</time>发表</span><span class="level-item"><time datetime="2023-08-11T05:42:07.400Z" title="2023/8/11 13:42:07">2023-08-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">26 分钟读完 (大约3866个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="Redis-是单线程吗？"><a href="#Redis-是单线程吗？" class="headerlink" title="Redis 是单线程吗？"></a>Redis 是单线程吗？</h3><p>Redis单线程指的是【接收客户端请求-&gt;解析请求-&gt;对数据进行读写操作-&gt;发送数据给客户端】这个过程由主线程完成的</p>
<p>在2.6版本会启动处理关闭文件和AOF刷盘任务</p>
<p>4.0版本会增加lazyFree线程释放内存，例如unlink key 、flushdb async、 flushall async 会把删除命令提交给后台线程操作，这样不会阻塞主线程，del会在主线程删除，对于大key最好还是使用unlink</p>
<p>这些都是耗时操作会阻塞主线程。三种任务都有各自的任务队列，会去消费这些任务</p>
<p><img src="https://cdn.jsdelivr.net/gh/leonyan18/image/redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="redis线程模型"></p>
<h3 id="6-0之前线程模型"><a href="#6-0之前线程模型" class="headerlink" title="6.0之前线程模型"></a>6.0之前线程模型</h3><p>创建socket 和epoll_create() 对象</p>
<p>bind()绑定端口 listen监听端口</p>
<p>epoll_ctl把listen socket加入到epoll，注册连接事件处理函数</p>
<p>调用epoll_wait() 循环：</p>
<ol>
<li>写检查发送队列中有无发送任务，有就调用write()函数将客户端缓冲区的数据发送出去，没有发完就会注册一个写事件处理函数，等到下一个epoll_wait() 函数会继续处理</li>
<li>连接事件，调用连接事件处理函数主要是调用accept()函数获取连接的socket 将连接的socket加入到epoll中 注册读事件</li>
<li>读事件，调用读事件处理函数主要是调用read函数 读取客户端发送的数据 解析数据 执行命令 将客户端添加到发送队列 将发送给客户端的数据写到缓冲区</li>
<li>写事件，调用写事件处理函数主要是调用write()函数将缓冲区的数据全部发送出去，如果还没有发完会继续注册写事件处理函数，等到下一个epoll_wait() 函数会继续处理</li>
</ol>
<h3 id="6-0之后"><a href="#6-0之后" class="headerlink" title="6.0之后"></a>6.0之后</h3><p>会对网络io请求进行多线程处理，默认只对写操作进行多线程处理</p>
<p>6.0之后的线程数</p>
<ol>
<li>主线程</li>
<li>关闭文件线程、AOF刷盘线程、Lazzfree线程</li>
<li>io线程*3（默认参数是4 主线程也算进io线程当中）</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Redis 提供了丰富的数据类型，常见的有五种：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）</strong>。</p>
<p>随着 Redis 版本的更新，后面又支持了四种数据类型： <strong>BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</strong>。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</p>
<p>SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：</p>
<ul>
<li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。</li>
<li>**SDS 获取字符串长度的时间复杂度是 O(1)**。SDS 结构里用 <code>len</code> 属性记录了字符串长度</li>
<li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。会自动扩容</li>
</ul>
<p>内部编码（encoding）有 3 种 ：<strong>int、raw（字符串的长度大于 32 字节）和 embstr（字符申的长度小于等于 32 字节）</strong>。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>分布式锁</p>
<p>缓存计数</p>
<p>共享session</p>
<span id="more"></span>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>如果列表的元素个数小于 <code>512</code> 个，列表每个元素的值都小于 <code>64</code> 字节，Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构，反之Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</p>
<p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。</p>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>基于 List 类型的消息队列，满足消息队列的三大需求（消息保序、处理重复的消息和保证消息可靠性）。</p>
<ul>
<li>消息保序：使用 LPUSH + RPOP；</li>
<li>阻塞读取：使用 BRPOP；</li>
<li>重复消息处理：生产者自行实现全局唯一 ID；</li>
<li>消息的可靠性：使用 BRPOPLPUSH</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p>
<p>如果集合中的元素都是整数且元素个数小于 <code>512</code> 个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构，反之则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</p>
<p>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p>
<p><strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong>。</p>
<p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p>
<h4 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h4><p>抽奖活动（去重）</p>
<p>共同关注（交并集）</p>
<h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>使用压缩列表或者跳表实现</p>
<p>当元素个数小于512的，且每个元素的值小于 <code>64</code> 字节时时候，使用压缩列表实现，反之使用跳表</p>
<h4 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h4><p>排行榜（有序列表，且可以单独增加value的值，并且能查询区间）</p>
<h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p>
<p>String 类型是会保存为二进制的字节数组</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BitMap间的运算</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">operations 位移操作符，枚举值</span></span><br><span class="line">  AND 与运算 &amp;</span><br><span class="line">  OR 或运算 |</span><br><span class="line">  XOR 异或 ^</span><br><span class="line">  NOT 取反 ~</span><br></pre></td></tr></tbody></table></figure>

<h4 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h4><ol>
<li>签到统计</li>
<li>判断用户登陆态</li>
<li>连续签到用户总数（与操作）</li>
</ol>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%。<strong>提供不精确的去重计数</strong>。</p>
<h4 id="应用-5"><a href="#应用-5" class="headerlink" title="应用"></a>应用</h4><p>统计网页访问者</p>
<h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>直接使用了 Sorted Set 集合类型。</p>
<h4 id="应用-6"><a href="#应用-6" class="headerlink" title="应用"></a>应用</h4><p>查找以这个经纬度为中心的 5 公里内的车辆信息</p>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Redis Stream 是 Redis 5.0 版本新增加</p>
<p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p>
<ul>
<li>发布订阅模式，<strong>不能持久化</strong>也就无法可靠的保存消息，并且对于离线重连的客户端<strong>不能读取历史消息</strong>的缺陷；</li>
<li>List 实现消息队列的方式<strong>不能重复消费</strong>，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID。</li>
</ul>
<p>基于 Stream 实现的消息队列</p>
<ul>
<li>消息保序：XADD/XREAD</li>
<li>阻塞读取：XREAD block</li>
<li>重复消息处理：Stream 在使用 XADD 命令，会自动生成全局唯一 ID；</li>
<li>消息可靠性：内部使用 PENDING List 自动保存消息，使用 XPENDING 命令查看消费组已经读取但是未被确认的消息，消费者使用 XACK 确认消息；</li>
<li>支持消费组形式消费数据</li>
</ul>
<p>但是与专业的消息队列对比，会存在丢消息的情况因为aof命令并不是先写到硬盘才写入到内存当中的</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><p>c语言字符串缺陷：获取长度O(n):缓冲区溢出;不能保存二进制；</p>
<h4 id="SDS数据结构"><a href="#SDS数据结构" class="headerlink" title="SDS数据结构"></a>SDS数据结构</h4><p><img src="https://cdn.jsdelivr.net/gh/leonyan18/image/516738c4058cdf9109e40a7812ef4239.png" alt="img"></p>
<ol>
<li><p>以处理二进制的方式来处理 SDS 存放在 buf[] 里的数据</p>
</li>
<li><p>当发现缓冲区不够的时候会自动进行扩容，所需空间超过1MB，新长度为所需空间+1MB，反之新长度为所需空间的两倍</p>
</li>
<li><p>flags标志了不同长度和空间占用的字符串，可以减少头部长度</p>
</li>
<li><p>编译器优化，可以取消字节对齐</p>
</li>
</ol>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>双向链表，封装了一层，增加了长度和其他节点比较函数、复制、释放</p>
<p>缺陷：链表通病</p>
<ol>
<li>无法利用cpu缓存</li>
<li>节点结构头开销</li>
</ol>
<h3 id="压缩链表"><a href="#压缩链表" class="headerlink" title="压缩链表"></a>压缩链表</h3><p><img src="https://cdn.xiaolincoding.com//mysql/other/a3b1f6235cf0587115b21312fe60289c.png" alt="img"></p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>查询操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/leonyan18/image/20201228011553.png" alt="img"></p>
<p>删除操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/leonyan18/image/20201228011642.png" alt="img"></p>
<p>插入操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/lxbwolf/blog_source_image@main/20201228011750.png" alt="img"></p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a>AOF 日志</h3><p><img src="https://cdn.jsdelivr.net/gh/leonyan18/image/6f0ab40396b7fc2c15e6f4487d3a0ad7.png" alt="img"></p>
<p>redis 里的 <strong>AOF(Append Only File)</strong> 持久化功能，<strong>注意只会记录写操作命令，读操作命令是不会被记录的</strong>，</p>
<p>先写命令的好处</p>
<ol>
<li>避免额外检查开销（记录到硬盘之前会先检查这个语法）</li>
<li>避免阻塞写命令</li>
</ol>
<p>坏处</p>
<ol>
<li>出现停电操作的时候，部分数据会丢失（和回写策略有关）</li>
<li>由于命令都是在主进程中执行，还是可能会阻塞下一个写命令</li>
</ol>
<h4 id="回写策略"><a href="#回写策略" class="headerlink" title="回写策略"></a>回写策略</h4><p><strong>Always</strong> 每次写入 AOF 文件数据后，就执行 fsync() 函数</p>
<p><strong>Everysec</strong>  创建一个异步任务来执行 fsync() 函数</p>
<p><strong>No</strong> 永不执行 fsync() 函数</p>
<h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h4><p><strong>在使用重写机制后，就会读取 name 最新的 value（键值对）</strong></p>
<p>重写过程由后台子进程进行操作，因为比较耗时避免阻塞主进程，</p>
<p>并且如果使用线程线程共享进程的资源，对共享内存进行读写的时候需要进行加锁，而父子进程，在创建时是共享数据的，但在修改的时候会生成自己的数据副本，<strong>写时复制</strong></p>
<p>具体过程（虚拟空间不同，物理空间相同，标记该物理内存的权限为<strong>只读</strong>。）</p>
<p><img src="https://cdn.jsdelivr.net/gh/leonyan18/image/5a1f2a90b5f3821c19bea3b7a5f27fa1.png" alt="img"></p>
<h5 id="主进程"><a href="#主进程" class="headerlink" title="主进程"></a>主进程</h5><p>在子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p>
<ul>
<li>执行客户端发来的命令；</li>
<li>将执行后的写命令追加到 「AOF 缓冲区」；</li>
<li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/leonyan18/image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309231944807.png" alt="在这里插入图片描述"></p>
<p>在完成重写之后，主进程会收到信号，</p>
<ol>
<li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li>
<li>将新的aof重命名，并将后面所有的写命令记录到新的aof文件中</li>
</ol>
<h3 id="RDB文件"><a href="#RDB文件" class="headerlink" title="RDB文件"></a>RDB文件</h3><p>save(主线程)和 bgsave(后台线程)</p>
<p>可以定时保存RDB文件，但是是一个比较重的方法频率得适当</p>
<h5 id="保存快照的时候，数据被修改"><a href="#保存快照的时候，数据被修改" class="headerlink" title="保存快照的时候，数据被修改"></a>保存快照的时候，数据被修改</h5><p>可以被修改，当主线程修改了某一块的数据就会发生写时复制，极端情况会发生内存会翻倍，写操作多的时候需要留意内存变化</p>
<h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>保存RDB并且在保存过程中的命令也会被写到重写缓冲区中最后以AOF的方式添加到末尾</p>
<h3 id="对过期key的处理"><a href="#对过期key的处理" class="headerlink" title="对过期key的处理"></a>对过期key的处理</h3><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p><strong>写入阶段：</strong>创建的时候 直接增加key  过期删除的时候显示删除 del</p>
<p><strong>重写阶段：</strong>会校验key的过期时间确保过期的key不会被写入到新的AOF文件当中</p>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p><strong>写入阶段：</strong>会对key进行校验</p>
<p><strong>加载阶段：</strong> 与主从服务器有关，如果是主服务器则不会加载，从服务器无论是否过期都会加载，但是在主从同步阶段就会被清空数据</p>
<h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指大量的应用请求无法在Redis缓存中进行处理，从而使得大量请求发送到数据库层，导致数据库压力过大甚至宕机。</p>
<ol>
<li>同一时间缓存中的数据大面积过期（增加随机时间，设置热点数据永不过期，服务降级(非核心数据可以直接返回错误)）</li>
<li>Redis 缓存实例发生故障宕机（前端限流，预防可部署高可用集群）</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指某个访问非常频繁的热点数据，<strong>大量并发请求集中在这一个点访问</strong>，在这个Key失效的瞬间，持续的大并发就穿破缓存，直接请求数据库</p>
<ol>
<li>提前预热，设置热点数据永不过期</li>
<li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li>
</ol>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透指用户要访问的数据<strong>既不在缓存中也不在数据库中</strong>，导致用户每次请求该数据时都要去数据库查一遍，然后返回空。</p>
<ol>
<li>接口检验（用户鉴权，判断是否合法）</li>
<li>缓存空值或者缺省值（缓存空值可以设置过期时间）</li>
<li>布隆过滤器（<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在</strong>）</li>
</ol>
<h2 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h2><p>添加带有过期时间的key的时候，会把其key和过期时间加入到过期字典当中，查询时会先判断是否在过期字典当中</p>
<p><img src="https://cdn.jsdelivr.net/gh/leonyan18/image/%E8%BF%87%E6%9C%9F%E5%88%A4%E6%96%AD%E6%B5%81%E7%A8%8B.jpg" alt="img"></p>
<h3 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h3><p><strong>定时删除</strong>（设置key的时候，增加定时事件，定时删除；优点：内存友好；缺点：过期较多的时候会占用较多cpu时间）</p>
<p><strong>惰性删除</strong>（不主动删除key，访问key时查询是否过期，然后再删除；优点：占用cpu资源少；缺点：内存不友好)</p>
<p><strong>定期删除</strong>（每隔一段时间 清理一次过期key）</p>
<p>Redis选择<strong>惰性+定期</strong></p>
<p>定期删除是<strong>每隔一段时间「随机」从数据库中取出一定数量（20）的 key 进行检查，并删除其中的过期key,如果过期key超过25%，会继续进行新一轮的定期删除，如果执行时间超过25ms就不会执行新的一轮。</strong></p>
<p>redis默认1s进行10次key过期检查</p>
<h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>不淘汰</p>
<p>过期key里  随机 最早过期淘汰 lru lfu</p>
<p>所有key 随机 lru lfu</p>
</div><div class="article-licensing box"><div class="licensing-title"><p><a href="http://dawnchannel.tech/2023/06/19/redis/">http://dawnchannel.tech/2023/06/19/redis/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>leon Yan</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-06-19</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-08-11</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i>&nbsp;<a class="link-muted" rel="tag" href="/tags/redis/">redis </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/images/alipay_qrcode.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/images/wechat_qrcode.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/06/26/MQ/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">消息队列</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/06/15/framework/"><span class="level-item">framework</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "f7657a3747c4697622b7c16afef4d4dd",
            repo: "blog",
            owner: "leonyan18",
            clientID: "4bd38af00fcd8ccc320a",
            clientSecret: "d17b52761b48076a3fbafb2cb4f90f9a5ea969be",
            admin: ["leonyan18"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="颜晨曦"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">颜晨曦</p><p class="is-size-6 is-block">研究生</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>浙江 台州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">15</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/leonyan18" target="_blank" rel="noopener"><i class="fab fa-github"></i>&nbsp;&nbsp;关注我</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#线程模型"><span class="level-left"><span class="level-item">1</span><span class="level-item">线程模型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Redis-是单线程吗？"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Redis 是单线程吗？</span></span></a></li><li><a class="level is-mobile" href="#6-0之前线程模型"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">6.0之前线程模型</span></span></a></li><li><a class="level is-mobile" href="#6-0之后"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">6.0之后</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据类型"><span class="level-left"><span class="level-item">2</span><span class="level-item">数据类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#String"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">String</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#应用"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">应用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#List"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">List</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#应用-1"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">应用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Set"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Set</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#应用-2"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">应用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Zset"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">Zset</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#应用-3"><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">应用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#BitMap"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">BitMap</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#应用-4"><span class="level-left"><span class="level-item">2.5.1</span><span class="level-item">应用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#HyperLogLog"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">HyperLogLog</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#应用-5"><span class="level-left"><span class="level-item">2.6.1</span><span class="level-item">应用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#GEO"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">GEO</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#应用-6"><span class="level-left"><span class="level-item">2.7.1</span><span class="level-item">应用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Stream"><span class="level-left"><span class="level-item">2.8</span><span class="level-item">Stream</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据结构"><span class="level-left"><span class="level-item">3</span><span class="level-item">数据结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#SDS"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">SDS</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#SDS数据结构"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">SDS数据结构</span></span></a></li></ul></li><li><a class="level is-mobile" href="#链表"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">链表</span></span></a></li><li><a class="level is-mobile" href="#压缩链表"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">压缩链表</span></span></a></li><li><a class="level is-mobile" href="#跳表"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">跳表</span></span></a></li></ul></li><li><a class="level is-mobile" href="#持久化"><span class="level-left"><span class="level-item">4</span><span class="level-item">持久化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#AOF-日志"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">AOF 日志</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#回写策略"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">回写策略</span></span></a></li><li><a class="level is-mobile" href="#重写机制"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">重写机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#主进程"><span class="level-left"><span class="level-item">4.1.2.1</span><span class="level-item">主进程</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#RDB文件"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">RDB文件</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#保存快照的时候，数据被修改"><span class="level-left"><span class="level-item">4.2.1.1</span><span class="level-item">保存快照的时候，数据被修改</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#混合持久化"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">混合持久化</span></span></a></li><li><a class="level is-mobile" href="#对过期key的处理"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">对过期key的处理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#AOF"><span class="level-left"><span class="level-item">4.4.1</span><span class="level-item">AOF</span></span></a></li><li><a class="level is-mobile" href="#RDB"><span class="level-left"><span class="level-item">4.4.2</span><span class="level-item">RDB</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#缓存异常"><span class="level-left"><span class="level-item">5</span><span class="level-item">缓存异常</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#缓存雪崩"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">缓存雪崩</span></span></a></li><li><a class="level is-mobile" href="#缓存击穿"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">缓存击穿</span></span></a></li><li><a class="level is-mobile" href="#缓存穿透"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">缓存穿透</span></span></a></li></ul></li><li><a class="level is-mobile" href="#过期删除策略"><span class="level-left"><span class="level-item">6</span><span class="level-item">过期删除策略</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#删除策略"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">删除策略</span></span></a></li></ul></li><li><a class="level is-mobile" href="#内存淘汰策略"><span class="level-left"><span class="level-item">7</span><span class="level-item">内存淘汰策略</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer=""></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/avatar.png" alt="blog" height="28"></a><p class="is-size-7"><span>© 2023 leon Yan</span>&nbsp;&nbsp;Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>&nbsp;&amp;&nbsp;<a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span><br><a target="_blank" href="https://beian.miit.gov.cn"><img style="width:16px;height:16px;" src="http://www.beian.gov.cn/img/new/gongan.png"><span>浙ICP备2022034733号-1</span></a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer=""></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer=""></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer=""></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer=""></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer=""></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer=""></script><script src="/js/night.js" defer=""></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer=""></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>